package main

import (
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

func main() {
	devMode := flag.Bool("dev", false, "Run in development mode (watch and serve)")
	flag.Parse()

	if *devMode {
		runDevMode()
		return
	}

	build()
}

func runDevMode() {
	fmt.Println("Starting development server at http://localhost:8080")

	// Initial build
	build()

	// Start server
	go func() {
		fs := http.FileServer(http.Dir("build"))
		http.Handle("/", fs)
		log.Fatal(http.ListenAndServe(":8080", nil))
	}()

	// Polling watcher
	ticker := time.NewTicker(500 * time.Millisecond)
	lastBuild := time.Now()

	for range ticker.C {
		if needsRebuild(lastBuild) {
			fmt.Println("Change detected. Rebuilding...")
			rebuildCSS() // Build CSS first
			build()      // Then Build HTML
			lastBuild = time.Now()
		}
	}
}

func needsRebuild(lastBuild time.Time) bool {
	// Check layouts and components
	paths := []string{
		"components/layouts/*.html",
		"components/common/*.html",
		"components/sections/*.html",
	}

	for _, p := range paths {
		files, _ := filepath.Glob(p)
		for _, f := range files {
			info, err := os.Stat(f)
			if err == nil && info.ModTime().After(lastBuild) {
				return true
			}
		}
	}
	return false
}

func rebuildCSS() {
	// Ensure directory exists
	os.MkdirAll("build/assets/css", 0755)
	cmd := exec.Command("./node_modules/.bin/tailwindcss", "-i", "./styles/globals.css", "-o", "build/assets/css/style.css", "--minify")
	if err := cmd.Run(); err != nil {
		fmt.Println("Error rebuilding CSS:", err)
	}
}

func build() {
	fmt.Println("Building site...")

	// 1. Prepare target directories
	pagesDir := "pages"
	buildDir := "build"

	// Ensure pages directory exists
	if err := os.MkdirAll(pagesDir, 0755); err != nil {
		log.Fatal(err)
	}

	// Ensure build directory exists
	if err := os.MkdirAll(buildDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 2. Parse all templates
	var tmpl *template.Template

	funcMap := template.FuncMap{
		"safe": func(s string) template.HTML {
			return template.HTML(s)
		},
		"section": func(s Section) (template.HTML, error) {
			// This function allows dynamic dispatch: {{ section . }}
			if tmpl == nil {
				return "", fmt.Errorf("template set is nil")
			}
			var buf bytes.Buffer
			if err := tmpl.ExecuteTemplate(&buf, s.TemplateName, s.Data); err != nil {
				return "", err
			}
			return template.HTML(buf.String()), nil
		},
	}

	tmpl = template.New("").Funcs(funcMap)

	// Glob patterns
	layoutFiles, err := filepath.Glob("components/layouts/*.html")
	if err != nil {
		log.Fatal(err)
	}
	commonFiles, err := filepath.Glob("components/common/*.html")
	if err != nil {
		log.Fatal(err)
	}
	sectionFiles, err := filepath.Glob("components/sections/*.html")
	if err != nil {
		log.Fatal(err)
	}

	// Combine all files
	allFiles := append(layoutFiles, commonFiles...)
	allFiles = append(allFiles, sectionFiles...)

	if len(allFiles) > 0 {
		_, err = tmpl.ParseFiles(allFiles...)
		if err != nil {
			log.Fatalf("Error parsing templates: %v", err)
		}
	}

	// 3. Get Content
	pages := GetSiteContent()

	// 4. Generate Pages into 'pages/' directory (Source)
	for _, page := range pages {
		fmt.Printf("Generating content for %s...\n", page.Path)

		// Determine path in pages directory
		outputPath := filepath.Join(pagesDir, page.Path)
		if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
			log.Fatal(err)
		}

		f, err := os.Create(outputPath)
		if err != nil {
			log.Fatal(err)
		}

		// Add "Do Not Edit" warning
		f.WriteString("<!-- \n  ⚠️  GENERATED FILE - DO NOT EDIT  ⚠️\n  This file is generated by the Go builder.\n  Edit content in 'cmd/builder/definitions.go' or templates in 'components/'.\n-->\n")

		err = tmpl.ExecuteTemplate(f, "base.html", page)
		if err != nil {
			log.Fatalf("Error executing template for %s: %v", page.Path, err)
		}
		f.Close()
	}

	// 5. Copy 'pages' content to 'build' (Distribution)
	fmt.Println("Copying pages to build directory...")
	copyDir(pagesDir, buildDir)

	// 6. Copy 'assets' content to 'build/assets' (Images, JS, etc)
	// We expect a root 'assets' folder
	fmt.Println("Copying assets to build directory...")
	copyDir("assets", filepath.Join(buildDir, "assets"))

	fmt.Println("Done.")
}

func copyDir(src, dst string) {
	// Walk source directory
	err := filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			// If source doesn't exist (e.g. no assets folder yet), just skip
			return nil
		}

		// Calculate destination path
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		destPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(destPath, info.Mode())
		}

		// Copy file
		sourceData, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		return os.WriteFile(destPath, sourceData, info.Mode())
	})

	if err != nil {
		fmt.Printf("Warning copying %s to %s: %v\n", src, dst, err)
	}
}
